#!/usr/bin/env python3
"""
Compute Service - OpenStack-equivalent Worker
Performs actual workload operations and data processing
"""
import os
import subprocess
from datetime import datetime
from flask import Flask, request, jsonify
from google.cloud import firestore, storage

app = Flask(__name__)

# Initialize GCP clients
db = firestore.Client()
storage_client = storage.Client()

@app.route('/health')
def health():
    return jsonify({'status': 'ok', 'service': 'compute'})

@app.route('/configure', methods=['POST'])
def configure():
    """Configure compute service"""
    config = request.json
    app.logger.info(f"Compute service configured: {config}")
    return jsonify({'status': 'configured'})

def validate_api_request():
    """Ensure request comes from API service"""
    return request.headers.get('X-Forwarded-From') == 'api-service'

@app.route('/execute', methods=['POST'])
def execute():
    """Execute allowed commands"""
    if not validate_api_request():
        return jsonify({'error': 'Unauthorized'}), 403
    
    command_data = request.json
    command = command_data.get('command', '').strip()
    
    # Basic commands allowed
    allowed_commands = {
        'ls': ['ls', '-la'],
        'ps': ['ps', 'aux'],
        'date': ['date'],
        'uptime': ['uptime']
    }
    
    if command in allowed_commands:
        try:
            result = subprocess.run(
                allowed_commands[command], 
                capture_output=True, 
                text=True, 
                timeout=5
            )
            return jsonify({
                'command': command,
                'output': result.stdout,
                'error': result.stderr,
                'returncode': result.returncode
            })
        except subprocess.TimeoutExpired:
            return jsonify({'error': 'Command timeout'}), 408
        except Exception as e:
            return jsonify({'error': str(e)}), 500
    
    return jsonify({'error': 'Command not allowed'}), 400

@app.route('/storage/<action>', methods=['GET', 'POST'])
def storage_operations(action):
    """Handle storage operations"""
    if not validate_api_request():
        return jsonify({'error': 'Unauthorized'}), 403
    
    bucket_name = os.getenv('STORAGE_BUCKET')
    if not bucket_name:
        return jsonify({'error': 'Storage bucket not configured'}), 500
    
    bucket = storage_client.bucket(bucket_name)
    
    if action == 'list':
        blobs = list(bucket.list_blobs())
        return jsonify({'files': [blob.name for blob in blobs]})
    
    elif action == 'upload' and request.method == 'POST':
        data = request.json
        filename = data.get('filename')
        content = data.get('content', '')
        
        if filename:
            blob = bucket.blob(filename)
            blob.upload_from_string(content)
            return jsonify({'status': 'uploaded', 'filename': filename})
    
    elif action == 'download':
        filename = request.args.get('filename')
        if filename:
            blob = bucket.blob(filename)
            content = blob.download_as_text()
            return jsonify({'filename': filename, 'content': content})
    
    return jsonify({'error': 'Invalid storage action'}), 400

@app.route('/database/<action>', methods=['GET', 'POST'])
def database_operations(action):
    """Handle Firestore operations"""
    if not validate_api_request():
        return jsonify({'error': 'Unauthorized'}), 403
    
    if action == 'write' and request.method == 'POST':
        data = request.json
        collection = data.get('collection', 'default')
        document_id = data.get('id', str(datetime.now().timestamp()))
        document_data = data.get('data', {})
        
        doc_ref = db.collection(collection).document(document_id)
        doc_ref.set(document_data)
        
        return jsonify({'status': 'written', 'id': document_id})
    
    elif action == 'read':
        collection = request.args.get('collection', 'default')
        docs = db.collection(collection).stream()
        
        results = []
        for doc in docs:
            results.append({'id': doc.id, 'data': doc.to_dict()})
        
        return jsonify({'documents': results})
    
    return jsonify({'error': 'Invalid database action'}), 400

@app.route('/generate/<content_type>')
def generate_content(content_type):
    """Generate different types of content"""
    if not validate_api_request():
        return jsonify({'error': 'Unauthorized'}), 403
    
    if content_type == 'html':
        html_content = f"""
        <html>
        <head><title>Generated Content</title></head>
        <body>
            <h1>Generated at {datetime.now()}</h1>
            <p>This content was generated by the compute service.</p>
            <p>Service status: Operational</p>
        </body>
        </html>
        """
        return html_content, 200, {'Content-Type': 'text/html'}
    
    elif content_type == 'json':
        return jsonify({
            'generated_at': datetime.now().isoformat(),
            'service': 'compute',
            'data': {'sample': 'data', 'count': 42}
        })
    
    return jsonify({'error': 'Unknown content type'}), 400

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)
